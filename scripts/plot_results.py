#!/usr/bin/env python3
"""
Plot benchmark results from a summary CSV generated by orchestrators.

Inputs:
  --summary: path to summary.csv (required)
  --out-dir: directory to write plots (required)

The CSV can be either full or latency-only.
Full columns:
    transport,payload,rate,run_id,sub_tps,p50_ms,p95_ms,p99_ms,pub_tps,sent,recv,errors,artifacts_dir,max_cpu_perc,max_mem_perc,max_mem_used_bytes
Latency-only columns:
    transport,payload,rate,run_id,p50_ms,p95_ms,p99_ms

Outputs:
    - throughput_vs_rate_payload<bytes>.png
    - p99_vs_rate_payload<bytes>.png
    - throughput-vs-fanout_payload<bytes>_rate<r>.png (if fanout rows exist)
    - max-cpu-vs-fanout_payload<bytes>_rate<r>.png (if fanout rows exist)
    - max-memory-vs-fanout_payload<bytes>_rate<r>.png (if fanout rows exist)
    - gallery.md (Markdown file embedding all figures)
"""
import argparse
import csv
import os
import math
import re
import sys
from collections import defaultdict
from typing import Tuple


def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser()
    p.add_argument("--summary", required=True, help="Path to summary.csv")
    p.add_argument("--out-dir", required=True, help="Output directory for plots")
    return p.parse_args()


# Marker and linestyle mapping per transport/broker for consistent visuals
# Supports labels like 'mqtt_emqx' and 'mqtt-emqx' (fanout plots)
MARKER_MAP = {
    "mqtt_mosquitto": "o",
    "mqtt_emqx": "s",
    "mqtt_hivemq": "^",
    "mqtt_rabbitmq": "D",
    "mqtt_artemis": "v",
    "mqtt": "o",
    "redis": "x",
    "nats": "P",
    "zenoh": "h",
    "rabbitmq": "*",
}

LINESTYLE_MAP = {
    "mqtt_mosquitto": "-",
    "mqtt_emqx": "--",
    "mqtt_hivemq": "-.",
    "mqtt_rabbitmq": ":",
    "mqtt_artemis": "-",
    "mqtt": "-",
    "redis": "--",
    "nats": "-.",
    "zenoh": "-",
    "rabbitmq": ":",
}

_MARKERS_CYCLE = ["o", "s", "^", "D", "v", "P", "X", "*", "h", "+", "x"]
_STYLES_CYCLE = ["-", "--", "-.", ":"]


def _norm_label(lbl: str) -> str:
    return (lbl or "").strip().lower().replace("-", "_")


def style_for(lbl: str) -> Tuple[str, str]:
    key = _norm_label(lbl)
    marker = MARKER_MAP.get(key)
    # All lines solid by default; keep marker distinct per broker/transport
    linestyle = "-"
    if marker is None:
        # Deterministic fallback based on label hash
        idx = abs(hash(key))
        marker = _MARKERS_CYCLE[idx % len(_MARKERS_CYCLE)]
    return marker, linestyle


def load_records(csv_path: str):
    recs = []
    with open(csv_path, newline="") as f:
        rd = csv.DictReader(f)
        for r in rd:
            try:
                item = {
                    "transport": r["transport"],
                    "payload": int(r["payload"]),
                    "rate": int(r["rate"]),
                    "sub_tps": float(r.get("sub_tps", "")) if r.get("sub_tps", "") else float("nan"),
                    "p50_ms": float(r.get("p50_ms", "")) if r.get("p50_ms", "") else float("nan"),
                    "p95_ms": float(r.get("p95_ms", "")) if r.get("p95_ms", "") else float("nan"),
                    "p99_ms": float(r["p99_ms"]) if r["p99_ms"] else float("nan"),
                    "max_cpu": float(r.get("max_cpu_perc", "") or float("nan")),
                    "max_mem_perc": float(r.get("max_mem_perc", "") or float("nan")),
                    "max_mem_bytes": float(r.get("max_mem_used_bytes", "") or float("nan")),
                    "run_id": r.get("run_id", ""),
                }
                # Extract pairs 'n<NNN>' from run_id if present
                rid = item.get("run_id", "")
                pairs = None
                if rid:
                    m = re.search(r"[_-]n(\d+)(?:[_-]|$)", rid)
                    if m:
                        try:
                            pairs = int(m.group(1))
                        except Exception:
                            pairs = None
                item["pairs"] = pairs
                recs.append(item)
            except Exception:
                # Skip malformed rows
                continue
    return recs


def unique_sorted(seq):
    return sorted(set(seq))


def add_legend_top(ax, fig, max_cols: int = 4, reserve_top: float = 0.82) -> None:
    """Place a de-duplicated legend at the top of the figure and reserve
    vertical space to avoid overlap with the title.

    reserve_top: fraction of figure height allocated to axes (leave 1-reserve_top for legend).
    """
    handles, labels = ax.get_legend_handles_labels()
    # De-duplicate while preserving order
    seen = set()
    handles2, labels2 = [], []
    for h, lbl in zip(handles, labels):
        if lbl in seen:
            continue
        seen.add(lbl)
        handles2.append(h)
        labels2.append(lbl)
    if not handles2:
        # Still tighten layout even if no legend
        try:
            fig.tight_layout()
        except Exception:
            pass
        return
    ncol = min(len(labels2), max_cols)
    # Reserve space for top legend, then place it
    try:
        fig.tight_layout(rect=(0, 0, 1, reserve_top))
    except Exception:
        pass
    fig.legend(handles2, labels2, loc="upper center", bbox_to_anchor=(0.5, 0.99), ncol=ncol, frameon=False)


def main() -> int:
    args = parse_args()
    os.makedirs(args.out_dir, exist_ok=True)

    # Matplotlib availability
    try:
        import matplotlib.pyplot as plt  # type: ignore
    except Exception as e:
        print(f"[plot] matplotlib not available: {e}\nInstall with: pip install matplotlib", file=sys.stderr)
        return 0

    records = load_records(args.summary)
    if not records:
        print("[plot] no records to plot", file=sys.stderr)
        return 0

    payloads = unique_sorted(r["payload"] for r in records)
    transports = unique_sorted(r["transport"] for r in records)

    # Detect latency-only input (no finite sub_tps anywhere)
    latency_only = all(not math.isfinite(rec.get("sub_tps", float("nan"))) for rec in records)

    # For rate-based plots, ignore fanout runs and any rows with non-positive rate or NaN metrics
    if latency_only:
        rate_records = [
            r for r in records
            if not str(r["transport"]).startswith("fanout-") and (r["rate"] or 0) > 0
        ]
    else:
        rate_records = [
            r for r in records
            if not str(r["transport"]).startswith("fanout-")
               and (r["rate"] or 0) > 0
               and math.isfinite(r.get("sub_tps", float("nan")))
        ]
    rates = unique_sorted(r["rate"] for r in rate_records)

    by_pt = defaultdict(list)
    for r in rate_records:
        by_pt[(r["payload"], r["transport"])].append(r)

    # Track images to build a markdown gallery at the end
    throughput_imgs = {}
    p99_imgs = {}
    cpu_imgs = {}
    mem_imgs = {}
    fanout_imgs = {}  # (payload, rate) -> filename
    fanout_cpu_imgs = {}  # (payload, rate) -> filename
    fanout_mem_imgs = {}  # (payload, rate) -> filename
    # New: latency vs payload (for each rate)
    p50_vs_payload_imgs = {}  # rate -> filename
    p95_vs_payload_imgs = {}  # rate -> filename
    p99_vs_payload_imgs = {}  # rate -> filename

    # Throughput vs offered rate (skip if latency-only)
    if not latency_only:
        for payload in payloads:
            fig, ax = plt.subplots(figsize=(7, 4))
            for t in transports:
                xs, ys = [], []
                # Preserve input order of rates on X axis
                for rate in rates:
                    vals = [r for r in by_pt[(payload, t)] if r["rate"] == rate]
                    if not vals:
                        continue
                    sub_tps = vals[0]["sub_tps"]
                    if not math.isfinite(sub_tps):
                        continue
                    xs.append(rate)
                    ys.append(sub_tps)
                if xs and ys:
                    m, ls = style_for(t)
                    ax.plot(xs, ys, marker=m, linestyle=ls, label=t)
            ax.set_title(f"Throughput vs Offered Rate (payload={payload}B)")
            ax.set_xlabel("Offered rate (msg/s)")
            ax.set_ylabel("Delivered throughput (msg/s)")
            ax.grid(True, alpha=0.3)
            add_legend_top(ax, fig)
            fn = os.path.join(args.out_dir, f"throughput_vs_rate_payload{payload}.png")
            fig.savefig(fn, dpi=150)
            throughput_imgs[payload] = os.path.basename(fn)
            plt.close(fig)

    # Throughput vs Pairs (when run_id includes n<N>)
    # Only meaningful for non-latency-only inputs
    if not latency_only:
        # Group by payload and transport, aggregate by pairs
        by_pt = defaultdict(list)
        for r in records:
            if not math.isfinite(r.get("sub_tps", float("nan"))):
                continue
            if r.get("pairs") is None:
                continue
            by_pt[(r["payload"], r["transport"])].append(r)
        throughput_pairs_imgs = {}
        for payload in payloads:
            fig, ax = plt.subplots(figsize=(7, 4))
            for t in transports:
                lst = by_pt.get((payload, t), [])
                if not lst:
                    continue
                lst = sorted(lst, key=lambda x: (x.get("pairs") or 0))
                xs = [x.get("pairs") for x in lst if x.get("pairs") is not None]
                ys = [x.get("sub_tps") for x in lst if x.get("pairs") is not None and math.isfinite(x.get("sub_tps", float("nan")))]
                if xs and ys:
                    m, ls = style_for(t)
                    ax.plot(xs, ys, marker=m, linestyle=ls, label=t)
            ax.set_title(f"Delivered Throughput vs Pairs (payload={payload}B)")
            ax.set_xlabel("Pairs (N publishers = N subscribers)")
            ax.set_ylabel("Delivered throughput (msg/s)")
            ax.grid(True, alpha=0.3)
            ax.set_xscale("log")
            add_legend_top(ax, fig)
            fn = os.path.join(args.out_dir, f"throughput_vs_pairs_payload{payload}.png")
            fig.savefig(fn, dpi=150)
            throughput_pairs_imgs[payload] = os.path.basename(fn)
            plt.close(fig)

    # P99 vs offered rate (skip if latency-only; it's rate-based summary)
    if not latency_only:
        for payload in payloads:
            fig, ax = plt.subplots(figsize=(7, 4))
            for t in transports:
                xs, ys = [], []
                for rate in rates:
                    vals = [r for r in by_pt[(payload, t)] if r["rate"] == rate]
                    if not vals:
                        continue
                    p99 = vals[0]["p99_ms"]
                    # Require finite and strictly positive for log-scale
                    if (not math.isfinite(p99)) or (p99 <= 0):
                        continue
                    xs.append(rate)
                    ys.append(p99)
                if xs and ys:
                    m, ls = style_for(t)
                    ax.plot(xs, ys, marker=m, linestyle=ls, label=t)
            ax.set_title(f"P99 latency vs Offered Rate (payload={payload}B)")
            ax.set_xlabel("Offered rate (msg/s)")
            ax.set_ylabel("P99 latency (ms)")
            # Use logarithmic Y-axis for latency
            try:
                ax.set_yscale("log")
            except Exception:
                pass
            ax.grid(True, alpha=0.3)
            add_legend_top(ax, fig)
            fn = os.path.join(args.out_dir, f"p99_vs_rate_payload{payload}.png")
            fig.savefig(fn, dpi=150)
            p99_imgs[payload] = os.path.basename(fn)
            plt.close(fig)

    # Max CPU% vs offered rate (skip if latency-only)
    if not latency_only:
        for payload in payloads:
            fig, ax = plt.subplots(figsize=(7, 4))
            for t in transports:
                xs, ys = [], []
                for rate in rates:
                    vals = [r for r in by_pt[(payload, t)] if r["rate"] == rate]
                    if not vals:
                        continue
                    mc = vals[0].get("max_cpu")
                    if mc is None or not math.isfinite(mc):
                        continue
                    xs.append(rate)
                    ys.append(mc)
                if xs and ys:
                    m, ls = style_for(t)
                    ax.plot(xs, ys, marker=m, linestyle=ls, label=t)
            ax.set_title(f"Max CPU% vs Offered Rate (payload={payload}B)")
            ax.set_xlabel("Offered rate (msg/s)")
            ax.set_ylabel("Max CPU (%)")
            ax.grid(True, alpha=0.3)
            add_legend_top(ax, fig)
            fn = os.path.join(args.out_dir, f"max_cpu_vs_rate_payload{payload}.png")
            fig.savefig(fn, dpi=150)
            cpu_imgs[payload] = os.path.basename(fn)
            plt.close(fig)

    # Max Memory% vs offered rate (skip if latency-only)
    if not latency_only:
        for payload in payloads:
            fig, ax = plt.subplots(figsize=(7, 4))
            for t in transports:
                xs, ys = [], []
                for rate in rates:
                    vals = [r for r in by_pt[(payload, t)] if r["rate"] == rate]
                    if not vals:
                        continue
                    mm = vals[0].get("max_mem_perc")
                    if mm is None or not math.isfinite(mm):
                        continue
                    xs.append(rate)
                    ys.append(mm)
                if xs and ys:
                    m, ls = style_for(t)
                    ax.plot(xs, ys, marker=m, linestyle=ls, label=t)
            ax.set_title(f"Max Memory% vs Offered Rate (payload={payload}B)")
            ax.set_xlabel("Offered rate (msg/s)")
            ax.set_ylabel("Max Memory (%)")
            ax.grid(True, alpha=0.3)
            add_legend_top(ax, fig)
            fn = os.path.join(args.out_dir, f"max_mem_vs_rate_payload{payload}.png")
            fig.savefig(fn, dpi=150)
            mem_imgs[payload] = os.path.basename(fn)
            plt.close(fig)

    # Latency vs Payload (for each offered rate)
    # One figure per rate; X = payload (bytes), Y = latency (ms); lines per transport
    from matplotlib.ticker import FuncFormatter, MaxNLocator

    def plot_latency_vs_payload(metric_key: str, title_prefix: str, dataset) -> dict:
        out = {}
        for rate in rates:
            fig, ax = plt.subplots(figsize=(7, 4))
            kb_set = set()
            for t in transports:
                # gather all records for this (rate, transport) across payloads
                lst = [r for r in dataset if r["rate"] == rate and r["transport"] == t]
                if not lst:
                    continue
                # sort by payload
                lst = sorted(lst, key=lambda x: x["payload"])
                xs, ys = [], []
                for r in lst:
                    val = r.get(metric_key)
                    # Require finite and strictly positive for log-scale
                    if val is None or (not math.isfinite(val)) or (val <= 0):
                        continue
                    # Convert bytes to KB for x-axis
                    x_kb = r["payload"] / 1024.0
                    xs.append(x_kb)
                    try:
                        kb_set.add(int(round(x_kb)))
                    except Exception:
                        pass
                    ys.append(val)
                if xs and ys:
                    m, ls = style_for(t)
                    ax.plot(xs, ys, marker=m, linestyle=ls, label=t)
            ax.set_title(f"{title_prefix} vs Payload (rate={rate}/s)")
            ax.set_xlabel("Payload size (KB)")
            ax.set_ylabel(f"{title_prefix} (ms)")
            # Use logarithmic Y-axis for latency
            try:
                ax.set_yscale("log")
            except Exception:
                pass
            ax.grid(True, alpha=0.3)
            # Use exact payload KBs as ticks; force-include 1KB tick for readability
            if kb_set:
                try:
                    kb_set.add(1)
                except Exception:
                    pass
                xs_sorted = sorted(kb_set)
                try:
                    ax.set_xlim(left=min(xs_sorted), right=max(xs_sorted))
                except Exception:
                    pass
                ax.set_xticks(xs_sorted)
            # Format ticks as plain integer values (in KB) without suffix
            ax.xaxis.set_major_formatter(FuncFormatter(lambda v, _: f"{int(round(v))}"))
            # Only apply a locator when we didn't set explicit ticks above
            if not kb_set:
                ax.xaxis.set_major_locator(MaxNLocator(nbins='auto', integer=True, min_n_ticks=3))
            add_legend_top(ax, fig)
            fn = os.path.join(args.out_dir, f"{metric_key}_vs_payload_rate{rate}.png")
            fig.savefig(fn, dpi=150)
            out[rate] = os.path.basename(fn)
            plt.close(fig)
        return out

    # Use the appropriate dataset for latency vs payload
    latency_dataset = rate_records
    # Generate p50/p95/p99 vs payload (per rate)
    p50_vs_payload_imgs = plot_latency_vs_payload("p50_ms", "P50 latency", latency_dataset)
    p95_vs_payload_imgs = plot_latency_vs_payload("p95_ms", "P95 latency", latency_dataset)
    p99_vs_payload_imgs = plot_latency_vs_payload("p99_ms", "P99 latency", latency_dataset)

    # Fanout plots: x = subscriber count, y = delivered throughput, per (payload, rate)
    fanout_rows = []
    subs_pat = re.compile(r"-s(\d+)$")
    for r in records:
        t = r["transport"]
        if t.startswith("fanout-"):
            m = subs_pat.search(t)
            if not m:
                continue
            try:
                subs = int(m.group(1))
            except Exception:
                continue
            # Normalize label e.g. fanout-mqtt-hivemq-s8 -> mqtt-hivemq
            base_label = t[: t.rfind("-s")]
            if base_label.startswith("fanout-"):
                base_label = base_label[len("fanout-"):]
            fanout_rows.append({
                "payload": r["payload"],
                "rate": r["rate"],
                "subs": subs,
                "sub_tps": r["sub_tps"],
                "max_cpu": r.get("max_cpu"),
                "max_mem_perc": r.get("max_mem_perc"),
                "label": base_label,
            })

    if fanout_rows:
        by_pr = defaultdict(list)  # (payload, rate) -> rows
        for r in fanout_rows:
            by_pr[(r["payload"], r["rate"])].append(r)
        for (payload, rate), rows in by_pr.items():
            # Group by label in case multiple fanout transport flavors exist
            by_label = defaultdict(list)
            for rr in rows:
                by_label[rr["label"]].append(rr)

            fig, ax = plt.subplots(figsize=(7, 4))
            for label, lst in by_label.items():
                lst = sorted(lst, key=lambda x: x["subs"])
                xs = [x["subs"] for x in lst if math.isfinite(x.get("sub_tps", float("nan")))]
                ys = [x["sub_tps"] for x in lst if math.isfinite(x.get("sub_tps", float("nan")))]
                m, ls = style_for(label)
                ax.plot(xs, ys, marker=m, linestyle=ls, label=label)
            ax.set_title(f"Delivered throughput vs Fanout (payload={payload}B, rate={rate}/s)")
            ax.set_xlabel("Fanout (subscribers)")
            ax.set_ylabel("Delivered throughput (msg/s)")
            ax.grid(True, alpha=0.3)
            add_legend_top(ax, fig)
            fn = os.path.join(args.out_dir, f"throughput-vs-fanout_payload{payload}_rate{rate}.png")
            fig.savefig(fn, dpi=150)
            fanout_imgs[(payload, rate)] = os.path.basename(fn)
            plt.close(fig)

            # CPU vs fanout
            fig, ax = plt.subplots(figsize=(7, 4))
            for label, lst in by_label.items():
                lst = sorted(lst, key=lambda x: x["subs"])
                xs, ys = [], []
                for x in lst:
                    v = x.get("max_cpu")
                    if v is None or not math.isfinite(v):
                        continue
                    xs.append(x["subs"]) 
                    ys.append(v)
                if xs and ys:
                    m, ls = style_for(label)
                    ax.plot(xs, ys, marker=m, linestyle=ls, label=label)
            ax.set_title(f"Max CPU% vs Fanout (payload={payload}B, rate={rate}/s)")
            ax.set_xlabel("Fanout (subscribers)")
            ax.set_ylabel("Max CPU (%)")
            ax.grid(True, alpha=0.3)
            add_legend_top(ax, fig)
            fn_cpu = os.path.join(args.out_dir, f"max-cpu-vs-fanout_payload{payload}_rate{rate}.png")
            fig.savefig(fn_cpu, dpi=150)
            fanout_cpu_imgs[(payload, rate)] = os.path.basename(fn_cpu)
            plt.close(fig)

            # Memory% vs fanout
            fig, ax = plt.subplots(figsize=(7, 4))
            for label, lst in by_label.items():
                lst = sorted(lst, key=lambda x: x["subs"])
                xs, ys = [], []
                for x in lst:
                    v = x.get("max_mem_perc")
                    if v is None or not math.isfinite(v):
                        continue
                    xs.append(x["subs"]) 
                    ys.append(v)
                if xs and ys:
                    m, ls = style_for(label)
                    ax.plot(xs, ys, marker=m, linestyle=ls, label=label)
            ax.set_title(f"Max Memory% vs Fanout (payload={payload}B, rate={rate}/s)")
            ax.set_xlabel("Fanout (subscribers)")
            ax.set_ylabel("Max Memory (%)")
            ax.grid(True, alpha=0.3)
            add_legend_top(ax, fig)
            fn_mem = os.path.join(args.out_dir, f"max-memory-vs-fanout_payload{payload}_rate{rate}.png")
            fig.savefig(fn_mem, dpi=150)
            fanout_mem_imgs[(payload, rate)] = os.path.basename(fn_mem)
            plt.close(fig)

    # Build a simple markdown gallery
    try:
        md_path = os.path.join(args.out_dir, "README.md")
        with open(md_path, "w", encoding="utf-8") as f:
            f.write("# Benchmark plots\n\n")
            f.write(f"- Summary: `{os.path.abspath(args.summary)}`\n\n")

            # Table of contents
            f.write("## Table of contents\n\n")
            if throughput_imgs:
                f.write("- [Throughput vs Offered Rate](#throughput-vs-offered-rate)\n")
            if p99_imgs:
                f.write("- [P99 latency vs Offered Rate](#p99-latency-vs-offered-rate)\n")
            if cpu_imgs:
                f.write("- [Max CPU% vs Offered Rate](#max-cpu-vs-offered-rate)\n")
            if mem_imgs:
                f.write("- [Max Memory% vs Offered Rate](#max-memory-vs-offered-rate)\n")
            if fanout_imgs:
                f.write("- [Fanout: Delivered throughput](#fanout-delivered-throughput)\n")
            if fanout_cpu_imgs:
                f.write("- [Fanout: Max CPU%](#fanout-max-cpu)\n")
            if fanout_mem_imgs:
                f.write("- [Fanout: Max Memory%](#fanout-max-memory)\n")
            f.write("\n")

            if throughput_imgs:
                f.write("## Throughput vs Offered Rate\n\n")
                for payload in payloads:
                    img = throughput_imgs.get(payload)
                    if not img:
                        continue
                    f.write(f"### payload={payload}B\n\n")
                    f.write(f"![throughput payload {payload}]({img})\n\n")

            # Insert Throughput vs Pairs section if generated
            try:
                if 'throughput_pairs_imgs' in locals() and throughput_pairs_imgs:
                    f.write("## Throughput vs Pairs\n\n")
                    for payload in payloads:
                        img = throughput_pairs_imgs.get(payload)
                        if not img:
                            continue
                        f.write(f"### payload={payload}B\n\n")
                        f.write(f"![throughput vs pairs payload {payload}]({img})\n\n")
            except Exception:
                pass

            if p99_imgs:
                f.write("## P99 latency vs Offered Rate\n\n")
                for payload in payloads:
                    img = p99_imgs.get(payload)
                    if not img:
                        continue
                    f.write(f"### payload={payload}B\n\n")
                    f.write(f"![p99 payload {payload}]({img})\n\n")

            if cpu_imgs:
                f.write("## Max CPU% vs Offered Rate\n\n")
                for payload in payloads:
                    img = cpu_imgs.get(payload)
                    if not img:
                        continue
                    f.write(f"### payload={payload}B\n\n")
                    f.write(f"![cpu payload {payload}]({img})\n\n")

            if mem_imgs:
                f.write("## Max Memory% vs Offered Rate\n\n")
                for payload in payloads:
                    img = mem_imgs.get(payload)
                    if not img:
                        continue
                    f.write(f"### payload={payload}B\n\n")
                    f.write(f"![mem payload {payload}]({img})\n\n")

            # Latency vs Payload (per rate)
            if p50_vs_payload_imgs or p95_vs_payload_imgs or p99_vs_payload_imgs:
                f.write("## Latency vs Payload\n\n")
                if p50_vs_payload_imgs:
                    f.write("### P50 latency\n\n")
                    for rate in sorted(p50_vs_payload_imgs.keys()):
                        img = p50_vs_payload_imgs[rate]
                        f.write(f"#### rate={rate}/s\n\n")
                        f.write(f"![p50 vs payload r{rate}]({img})\n\n")
                if p95_vs_payload_imgs:
                    f.write("### P95 latency\n\n")
                    for rate in sorted(p95_vs_payload_imgs.keys()):
                        img = p95_vs_payload_imgs[rate]
                        f.write(f"#### rate={rate}/s\n\n")
                        f.write(f"![p95 vs payload r{rate}]({img})\n\n")
                if p99_vs_payload_imgs:
                    f.write("### P99 latency\n\n")
                    for rate in sorted(p99_vs_payload_imgs.keys()):
                        img = p99_vs_payload_imgs[rate]
                        f.write(f"#### rate={rate}/s\n\n")
                        f.write(f"![p99 vs payload r{rate}]({img})\n\n")

            if fanout_imgs:
                f.write("## Fanout: Delivered throughput\n\n")
                # Group by payload, then rate for consistent order
                pr_keys = sorted(fanout_imgs.keys())
                by_p = defaultdict(list)
                for (p, r) in pr_keys:
                    by_p[p].append(r)
                for p in sorted(by_p.keys()):
                    f.write(f"### payload={p}B\n\n")
                    for r in sorted(set(by_p[p])):
                        img = fanout_imgs.get((p, r))
                        if not img:
                            continue
                        f.write(f"#### rate={r}/s\n\n")
                        f.write(f"![fanout p{p} r{r}]({img})\n\n")

            if fanout_cpu_imgs:
                f.write("## Fanout: Max CPU%\n\n")
                pr_keys = sorted(fanout_cpu_imgs.keys())
                by_p = defaultdict(list)
                for (p, r) in pr_keys:
                    by_p[p].append(r)
                for p in sorted(by_p.keys()):
                    f.write(f"### payload={p}B\n\n")
                    for r in sorted(set(by_p[p])):
                        img = fanout_cpu_imgs.get((p, r))
                        if not img:
                            continue
                        f.write(f"#### rate={r}/s\n\n")
                        f.write(f"![fanout cpu p{p} r{r}]({img})\n\n")

            if fanout_mem_imgs:
                f.write("## Fanout: Max Memory%\n\n")
                pr_keys = sorted(fanout_mem_imgs.keys())
                by_p = defaultdict(list)
                for (p, r) in pr_keys:
                    by_p[p].append(r)
                for p in sorted(by_p.keys()):
                    f.write(f"### payload={p}B\n\n")
                    for r in sorted(set(by_p[p])):
                        img = fanout_mem_imgs.get((p, r))
                        if not img:
                            continue
                        f.write(f"#### rate={r}/s\n\n")
                        f.write(f"![fanout mem p{p} r{r}]({img})\n\n")

        print("[plot] Wrote plots to", args.out_dir)
        print("[plot] Wrote gallery:", md_path)
    except Exception as e:
        print(f"[plot] failed to write README.md: {e}", file=sys.stderr)
        print("[plot] Wrote plots to", args.out_dir)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
